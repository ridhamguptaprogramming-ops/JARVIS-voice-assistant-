#!/usr/bin/env python3
"""
JARVIS AI Brain Orchestrator

Turns broad requests into executable task outputs:
- Website scaffolds
- App scaffolds
- Legal/court draft packs
- Problem-solving reports
- Generic execution plans
"""

from __future__ import annotations

import argparse
import os
import re
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import List, Tuple

from ai_chat import get_ai_response


ERROR_PREFIXES = (
    "AI module missing",
    "I need an API key",
    "I cannot load an AI model",
    "I am having trouble",
)


@dataclass
class TaskResult:
    summary: str
    outputs: List[Path]


def _is_ai_error(text: str) -> bool:
    return any(text.startswith(prefix) for prefix in ERROR_PREFIXES)


def _strip_markdown_fences(text: str) -> str:
    cleaned = text.strip()
    if not cleaned.startswith("```"):
        return cleaned

    lines = cleaned.splitlines()
    if len(lines) <= 2:
        return cleaned.strip("`").strip()

    if lines[0].startswith("```"):
        lines = lines[1:]
    if lines and lines[-1].startswith("```"):
        lines = lines[:-1]
    return "\n".join(lines).strip()


def _ask_ai(prompt: str, mode: str) -> str:
    response = get_ai_response(prompt, mode=mode).strip()
    if not response or _is_ai_error(response):
        return ""
    return _strip_markdown_fences(response)


def _workspace_root() -> Path:
    return Path(__file__).resolve().parent.parent


def _brain_workspace() -> Path:
    root = _workspace_root() / "ai_workspace"
    root.mkdir(parents=True, exist_ok=True)
    return root


def _slugify(text: str, fallback: str = "task") -> str:
    slug = re.sub(r"[^a-zA-Z0-9]+", "_", text.lower()).strip("_")
    if not slug:
        slug = fallback
    return slug[:48]


def _extract_name(request: str, default: str) -> str:
    match = re.search(r"\b(?:called|named)\s+([a-zA-Z0-9_-]{2,40})\b", request, re.IGNORECASE)
    if match:
        return _slugify(match.group(1), default)

    words = re.findall(r"[a-zA-Z0-9]+", request.lower())
    keep = [w for w in words if w not in {"create", "build", "make", "for", "with", "and", "the", "an", "a"}]
    if not keep:
        return default
    return _slugify("_".join(keep[:4]), default)


def _detect_intent(request: str) -> str:
    lower = request.lower()

    legal_words = ("court", "legal", "contract", "agreement", "notice", "case", "law")
    website_words = ("website", "web app", "webpage", "landing page", "frontend", "portfolio site")
    problem_words = ("solve", "problem", "debug", "issue", "error", "root cause", "fix")
    app_words = ("app", "application", "mobile app", "software", "api")

    if any(word in lower for word in legal_words):
        return "legal"
    if any(word in lower for word in website_words):
        return "website"
    if any(word in lower for word in problem_words):
        return "problem"
    if any(word in lower for word in app_words):
        return "app"
    return "general"


def _write(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content.rstrip() + "\n", encoding="utf-8")


def _default_plan(request: str, intent: str) -> str:
    return (
        f"Task Intent: {intent}\n\n"
        f"Request: {request}\n\n"
        "Execution Plan:\n"
        "1. Confirm objective and acceptance criteria.\n"
        "2. Build a small working baseline quickly.\n"
        "3. Add error handling, security checks, and structure.\n"
        "4. Validate output quality with simple tests.\n"
        "5. Document usage and next iteration steps.\n"
    )


def _build_plan(request: str, intent: str) -> str:
    ai_prompt = (
        f"You are JARVIS execution planner. Intent: {intent}. "
        f"User request: {request}. "
        "Return a concise, practical implementation plan with numbered steps."
    )
    ai_plan = _ask_ai(ai_prompt, mode="plan")
    if ai_plan:
        return ai_plan
    return _default_plan(request, intent)


def _website_defaults(project_name: str) -> Tuple[str, str, str]:
    html = f"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{project_name.replace("_", " ").title()}</title>
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <header class="hero">
    <h1>{project_name.replace("_", " ").title()}</h1>
    <p>Generated by JARVIS AI Brain.</p>
    <button id="ctaBtn">Get Started</button>
  </header>
  <main>
    <section>
      <h2>Overview</h2>
      <p>This is your starter website scaffold.</p>
    </section>
  </main>
  <script src="./app.js"></script>
</body>
</html>
"""
    css = """* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: "Segoe UI", sans-serif;
  background: #f5f8fc;
  color: #102a43;
}
.hero {
  padding: 56px 20px;
  background: linear-gradient(140deg, #0e4a7a 0%, #0f6cb0 100%);
  color: #ffffff;
  text-align: center;
}
button {
  border: 0;
  border-radius: 8px;
  padding: 10px 16px;
  background: #f06c2f;
  color: #ffffff;
  font-weight: 700;
  cursor: pointer;
}
main {
  max-width: 900px;
  margin: 24px auto;
  padding: 0 16px;
}
"""
    js = """const ctaBtn = document.getElementById("ctaBtn");

if (ctaBtn) {
  ctaBtn.addEventListener("click", () => {
    alert("JARVIS website scaffold is ready for customization.");
  });
}
"""
    return html, css, js


def _create_website_task(request: str) -> TaskResult:
    workspace = _brain_workspace() / "projects"
    project_name = _extract_name(request, default="new_website")
    project_dir = workspace / f"{project_name}_website"
    project_dir.mkdir(parents=True, exist_ok=True)

    plan = _build_plan(request, "website")
    default_html, default_css, default_js = _website_defaults(project_name)

    html_prompt = (
        f"Create a complete HTML file for this website request: {request}. "
        "Use external files styles.css and app.js. Return only HTML."
    )
    css_prompt = (
        f"Create a complete CSS file for this website request: {request}. "
        "Return only CSS."
    )
    js_prompt = (
        f"Create a complete JavaScript file for this website request: {request}. "
        "Return only JavaScript."
    )

    html = _ask_ai(html_prompt, mode="code") or default_html
    css = _ask_ai(css_prompt, mode="code") or default_css
    js = _ask_ai(js_prompt, mode="code") or default_js

    index_file = project_dir / "index.html"
    styles_file = project_dir / "styles.css"
    app_file = project_dir / "app.js"
    plan_file = project_dir / "PLAN.md"
    readme_file = project_dir / "README.md"

    _write(index_file, html)
    _write(styles_file, css)
    _write(app_file, js)
    _write(plan_file, plan)
    _write(
        readme_file,
        (
            f"# {project_name.replace('_', ' ').title()} Website\n\n"
            "Created by JARVIS AI Brain.\n\n"
            "Files:\n"
            "- index.html\n"
            "- styles.css\n"
            "- app.js\n"
            "- PLAN.md\n"
        ),
    )

    return TaskResult(
        summary=f"AI brain completed website task. Created {project_dir}. Open index.html to preview.",
        outputs=[project_dir, index_file, styles_file, app_file, plan_file, readme_file],
    )


def _app_defaults(project_name: str, is_api: bool) -> Tuple[str, str]:
    if is_api:
        app_code = """from flask import Flask, jsonify

app = Flask(__name__)


@app.get("/")
def home():
    return jsonify({"message": "JARVIS API is running"})


@app.get("/health")
def health():
    return jsonify({"status": "ok"})


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
"""
        requirements = "Flask>=3.0.0\n"
        return app_code, requirements

    app_code = f"""def main() -> None:
    print("Welcome to {project_name.replace("_", " ").title()} app scaffold.")


if __name__ == "__main__":
    main()
"""
    requirements = ""
    return app_code, requirements


def _create_app_task(request: str) -> TaskResult:
    workspace = _brain_workspace() / "projects"
    project_name = _extract_name(request, default="new_app")
    project_dir = workspace / f"{project_name}_app"
    project_dir.mkdir(parents=True, exist_ok=True)

    lower = request.lower()
    is_api = "api" in lower or "flask" in lower or "backend" in lower
    plan = _build_plan(request, "app")
    default_app, default_requirements = _app_defaults(project_name, is_api=is_api)

    if is_api:
        app_prompt = (
            f"Create a production-style Flask app for this request: {request}. "
            "Include a root endpoint and a health endpoint. Return only Python code."
        )
        app_file = project_dir / "app.py"
    else:
        app_prompt = (
            f"Create a clean Python starter application for this request: {request}. "
            "Return only Python code."
        )
        app_file = project_dir / "main.py"

    ai_app = _ask_ai(app_prompt, mode="code")
    app_code = ai_app or default_app

    requirements = (
        _ask_ai(
            f"Provide requirements.txt for this app request: {request}. Return only plain text package lines.",
            mode="code",
        )
        or default_requirements
    )

    plan_file = project_dir / "PLAN.md"
    requirements_file = project_dir / "requirements.txt"
    readme_file = project_dir / "README.md"

    _write(app_file, app_code)
    _write(plan_file, plan)
    _write(requirements_file, requirements)
    _write(
        readme_file,
        (
            f"# {project_name.replace('_', ' ').title()} App\n\n"
            "Created by JARVIS AI Brain.\n\n"
            f"Entry file: `{app_file.name}`\n"
            "Plan: `PLAN.md`\n"
        ),
    )

    return TaskResult(
        summary=f"AI brain completed app task. Created {project_dir}.",
        outputs=[project_dir, app_file, plan_file, requirements_file, readme_file],
    )


def _create_legal_task(request: str) -> TaskResult:
    workspace = _brain_workspace() / "legal"
    topic = _extract_name(request, default="court_request")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    doc_file = workspace / f"{topic}_{timestamp}.md"

    legal_prompt = (
        "Create a structured legal preparation draft. "
        "User request: "
        f"{request}. "
        "Include sections: Background, Facts, Issues, Evidence Checklist, Questions for Lawyer, Next Actions. "
        "Do not provide final legal advice."
    )
    ai_legal = _ask_ai(legal_prompt, mode="plan")
    legal_body = ai_legal or (
        "## Background\n- Describe the situation clearly.\n\n"
        "## Facts\n- Date, people, actions, documents.\n\n"
        "## Issues\n- What legal questions must be answered.\n\n"
        "## Evidence Checklist\n- Contracts, emails, receipts, photos, witnesses.\n\n"
        "## Questions for Lawyer\n- Jurisdiction, timelines, risk, likely outcomes.\n\n"
        "## Next Actions\n1. Organize all evidence.\n2. Consult a licensed lawyer.\n3. Keep a dated timeline.\n"
    )

    content = (
        "# Legal/Court Preparation Draft\n\n"
        f"Request: {request}\n\n"
        "**Important:** This is an AI-generated preparation draft, not legal advice.\n\n"
        f"{legal_body}\n"
    )
    _write(doc_file, content)

    return TaskResult(
        summary=f"AI brain prepared a legal/court draft at {doc_file}.",
        outputs=[doc_file],
    )


def _create_problem_task(request: str) -> TaskResult:
    workspace = _brain_workspace() / "solutions"
    topic = _extract_name(request, default="problem")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    solution_file = workspace / f"{topic}_{timestamp}.md"

    analysis_prompt = (
        f"Solve this problem request: {request}. "
        "Return a concise root-cause analysis, options, recommended fix, and validation checks."
    )
    ai_solution = _ask_ai(analysis_prompt, mode="plan")
    solution_text = ai_solution or (
        "## Problem Definition\n- Clarify expected vs actual behavior.\n\n"
        "## Root Cause Hypothesis\n- Identify likely causes and rank by probability.\n\n"
        "## Recommended Fix\n- Implement smallest safe fix first.\n\n"
        "## Validation\n- Add tests and measure outcome.\n"
    )

    content = f"# Problem Solving Report\n\nRequest: {request}\n\n{solution_text}\n"
    _write(solution_file, content)

    return TaskResult(
        summary=f"AI brain generated a problem-solving report at {solution_file}.",
        outputs=[solution_file],
    )


def _create_general_task(request: str) -> TaskResult:
    workspace = _brain_workspace() / "plans"
    topic = _extract_name(request, default="task")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    plan_file = workspace / f"{topic}_{timestamp}.md"

    plan = _build_plan(request, "general")
    content = f"# AI Task Plan\n\nRequest: {request}\n\n{plan}\n"
    _write(plan_file, content)

    return TaskResult(
        summary=f"AI brain created a task plan at {plan_file}.",
        outputs=[plan_file],
    )


def run_request(request: str) -> TaskResult:
    cleaned = request.strip()
    if not cleaned:
        return TaskResult(summary="Please provide a task request.", outputs=[])

    intent = _detect_intent(cleaned)
    if intent == "website":
        return _create_website_task(cleaned)
    if intent == "app":
        return _create_app_task(cleaned)
    if intent == "legal":
        return _create_legal_task(cleaned)
    if intent == "problem":
        return _create_problem_task(cleaned)
    return _create_general_task(cleaned)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="JARVIS AI brain orchestrator")
    parser.add_argument("--request", required=True, help="Task request text")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    result = run_request(args.request)

    if not result.outputs:
        print(result.summary)
        return

    rel_outputs = []
    root = _workspace_root()
    for path in result.outputs[:4]:
        try:
            rel_outputs.append(str(path.relative_to(root)))
        except ValueError:
            rel_outputs.append(str(path))

    print(f"{result.summary} Outputs: {', '.join(rel_outputs)}")


if __name__ == "__main__":
    main()
